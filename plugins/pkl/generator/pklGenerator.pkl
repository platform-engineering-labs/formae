/*
 * Â© 2025 Platform Engineering Labs Inc.
 *
 * SPDX-License-Identifier: FSL-1.1-ALv2
 */

module FormaGenerator

import "./gen.pkl" as gen
import "@formae/formae.pkl"
import "./resources.pkl"
import "pkl:json"

resourceTypes = resources.GetAllResourceTypes()
typeMap = resourceTypes.fold(Map(), (acc: Map<String, resources.Resource>, elem) ->
    acc.put(elem.type, elem)
)

function headerImports(): String =
    """
    amends "@formae/forma.pkl"
    import "@formae/formae.pkl"
    """

function getImports(type: String, dependencies: List<String>): String =
    """
    amends "@formae/forma.pkl"
    import "@formae/formae.pkl"


    \(dependencies.map((dep) -> "import \"\(dep)\"").join("\n"))
    """

function toCamelCase(input: String): String =
    if (input == "$unmanaged")
        "myStack"
    else
        let (parts = input.split("-"))
        if (parts.length == 1)
            input
        else
            parts.first + parts.drop(1).map((part) ->
                if (part.isEmpty) ""
                else part.substring(0, 1).toUpperCase() + part.substring(1, part.length)
            ).join("")

function appendProperties(parsed: json.Value): json.Value =
    new Dynamic {
        ...parsed.Properties
        label = parsed.Label
    }

/// Derive a unique Pkl identifier alias from a module path.
/// When the simple filename would collide with another import in the set,
/// prepend the parent directory segment.
/// e.g., "@cloudflare-dns/cloudflare-dns.pkl" -> "cloudflare_dns"
/// e.g., "@aws/ec2/ec2.pkl" -> "ec2"
/// e.g., "@aws/ecs/service.pkl" + "@gcp/cloudrun/service.pkl" -> "ecs_service" / "cloudrun_service"
function modulePathToAlias(modulePath: String, allPaths: List<String>): String =
    let (segments = modulePath.replaceAll(".pkl", "").split("/"))
    let (baseName = segments.last.replaceAll("-", "_"))
    let (hasCollision = allPaths.filter((p) ->
        p != modulePath && p.replaceAll(".pkl", "").split("/").last.replaceAll("-", "_") == baseName
    ).length > 0)
    if (hasCollision && segments.length >= 2)
        let (parent = segments[segments.length - 2].replaceAll("-", "_").replaceFirst("@", ""))
        "\(parent)_\(baseName)"
    else
        baseName

function importFormatting(imports: List<String>, allImports: List<String>): String =
    imports.map((i) ->
        let (alias = modulePathToAlias(i, allImports))
        "import \"\(i)\" as \(alias)"
    ).join("\n")

function parseStacks(stacksData: List<Map<String, Any>>, policyLabelMap: Map<String, String>): String =
    let (stacksString = stacksData.map((stackData) ->
        let (label = stackData["label"])
        let (camelCaseLabel = toCamelCase(label))
        let (description = stackData.getOrNull("description") ?? "This was generated")
        let (policies = stackData.getOrNull("policies") as List?)

        let (labelLine = if (label == "$unmanaged")
            """
            // Please provide a stack to bring the resources in this Forma under management
            // label = ""
            """
        else
            "        label = \"\(label)\""
        )

        // Generate policies line if stack has policy references or inline policies
        let (policiesLine = if (policies != null && policies.length > 0)
            let (policyEntries = policies.map((policy) ->
                // Check if it's a $ref (policy reference) or inline policy
                // Policy comes as Dynamic from JSON, access properties directly
                let (ref = policy.getPropertyOrNull("$ref") as String?)
                if (ref != null && ref.startsWith("policy://"))
                    // It's a policy reference - extract label and look up camelCase name
                    let (policyLabel = ref.replaceFirst("policy://", ""))
                    let (policyVarName = policyLabelMap.getOrNull(policyLabel) ?? toCamelCase(policyLabel))
                    "\(policyVarName).res"
                else
                    // Inline policy - render directly (without label, as it's typically auto-generated)
                    let (policyType = policy.getPropertyOrNull("Type") as String?)
                    if (policyType == "ttl")
                        let (ttlSeconds = policy.getPropertyOrNull("TTLSeconds") as Number? ?? 0)
                        let (onDependents = policy.getPropertyOrNull("OnDependents") as String? ?? "abort")
                        """
                        new formae.TTLPolicy {
                                    ttl = \(ttlSeconds).s
                                    onDependents = "\(onDependents)"
                                }
                        """
                    else if (policyType == "auto-reconcile")
                        let (intervalSeconds = policy.getPropertyOrNull("IntervalSeconds") as Number? ?? 0)
                        """
                        new formae.AutoReconcilePolicy {
                                    interval = \(intervalSeconds).s
                                }
                        """
                    else
                        null
            ).filter((p) -> p != null))
            if (policyEntries.length > 0)
                "\n        policies = new Listing { \(policyEntries.join("; ")) }"
            else
                ""
        else
            ""
        )

        """

      local \(camelCaseLabel) = new formae.Stack {
        \(labelLine)
        description = "\(description)"\(policiesLine)
      }
      \(camelCaseLabel)
      """
    ))
    stacksString.join("\n")

/// Parses standalone policies and generates PKL output
function parsePolicies(policiesData: List<Map<String, Any>>): String =
    let (policiesString = policiesData.map((policyData) ->
        let (policyType = policyData["Type"] as String)
        let (label = policyData["Label"] as String)
        let (camelCaseLabel = toCamelCase(label))

        if (policyType == "ttl")
            let (ttlSeconds = policyData["TTLSeconds"] as Number)
            let (onDependents = policyData.getOrNull("OnDependents") as String? ?? "abort")
            """

      local \(camelCaseLabel) = new formae.TTLPolicy {
        label = "\(label)"
        ttl = \(ttlSeconds).s
        onDependents = "\(onDependents)"
      }
      \(camelCaseLabel)
      """
        else if (policyType == "auto-reconcile")
            let (intervalSeconds = policyData["IntervalSeconds"] as Number)
            """

      local \(camelCaseLabel) = new formae.AutoReconcilePolicy {
        label = "\(label)"
        interval = \(intervalSeconds).s
      }
      \(camelCaseLabel)
      """
        else
            // Unknown policy type - skip with comment
            """

      // Skipped unknown policy type: \(policyType) (label: \(label))
      """
    ))
    policiesString.join("\n")

function parseTargets(targetsData: List<Map<String, Any>>): String =
    let (targetsString = targetsData.map((targetData) ->
        let (label = targetData["label"])
        let (discoverable = targetData.getOrNull("discoverable"))
        let (camelCaseLabel = toCamelCase(label))
        let (config = targetData["config"])
        let (namespace = targetData.getOrNull("namespace") ?? "aws")

        // Generate config properties if config exists
        let (configString = if (config != null)
            let (configMap = config.toMap())
            let (configLines = configMap.fold(List(), (acc: List<String>, key: String, value: Any) ->
                let (valueString = if (value is String) "\"\(value)\"" else value.toString())
                acc.add("      \(key) = \(valueString)")
            ))
            if (configLines.isEmpty) ""
            else
        """

          config {
        \(configLines.join("\n"))
            }
        """
        else ""
        )

        """

      local \(camelCaseLabel) = new formae.Target {
        label = "\(label)"
        namespace = "\(namespace)"\(if (discoverable != null) "\n        discoverable = \(discoverable)" else "")\(configString)
      }
      \(camelCaseLabel)
      """
    ))
    targetsString.join("\n")

function parseResources(resources: List<String>, targetMap: Map<String, String>, stackMap: Map<String, String>): String =
    let (resourcesString = resources.map((r) ->
        // Replace target references in the resource string with camelCase versions
        let (withTargets = targetMap.fold(r, (acc: String, originalLabel: String, camelCaseLabel: String) ->
            acc.replaceAll("target = \"\(originalLabel)\"", "target = \(camelCaseLabel).res")
        ))
        // Replace stack references in the resource string with camelCase versions
        stackMap.fold(withTargets, (acc: String, originalLabel: String, camelCaseLabel: String) ->
            acc.replaceAll("stack = \"\(originalLabel)\"", "stack = \(camelCaseLabel).res").replaceAll("stack = \"\(originalLabel).Label\"", "stack = \(camelCaseLabel).res.Label")
        )
    ))
    resourcesString.join("\n\n")

function generateFormaFile(parsed: json.Value): String =
    let (parsedList = parsed.Resources.toList())

    // Phase 1: Pre-compute pklMaps for all resources
    let (pklMaps = parsedList.map((resource) ->
        let (resourceType = resource.Type)
        let (properties = appendProperties(resource))
        gen.genPklToMap(gen.applyResource(typeMap[resourceType].clazz, properties).toDynamic()).put("target", resource.Target).put("stack", resource.Stack)
    ))

    // Phase 2: Collect all imports for collision-aware alias computation
    let (resourceImports = parsedList.map((resource) -> typeMap[resource.Type].moduleName).distinct)
    // Get unique namespaces from resource types and add base module imports for Tag support (e.g., @azure/azure.pkl)
    let (namespaceBaseImports = parsedList.map((resource) ->
        let (resourceImport = typeMap[resource.Type].moduleName)
        let (packageName = resourceImport.split("/").first.replaceFirst("@", ""))
        "@" + packageName + "/" + packageName + ".pkl"
    ).distinct)
    // Combine and deduplicate - for flat package structures, resourceImport and namespaceImport may be the same
    let (imports = (resourceImports + namespaceBaseImports).distinct)
    let (dependencyImports = pklMaps.flatMap((pklMap) -> gen.generateImportStatements(pklMap)).distinct.filter((e) -> !imports.contains(e)))
    let (allImports = (imports + dependencyImports).distinct)

    // Phase 3: Render resources with collision-aware aliases
    let (resources = parsedList.foldIndexed(List(), (index: Int, acc: List, resource) ->
        let (resourceType = resource.Type)
        let (className = typeMap[resourceType].className)
        let (resourceImport = typeMap[resourceType].moduleName)
        let (alias = modulePathToAlias(resourceImport, allImports))
        let (pklMap = pklMaps[index])
        acc.add(gen.genMapToPklStringWithTypes(className, pklMap, alias))
    ))

    // Extract target data from the parsed JSON
    let (targetsFromJson = parsed.Targets.toList().map((target) -> Map(
            "label", target.Label,
            "namespace", target.Namespace ?? "aws",
            "config", target.Config,
            "discoverable", target.getPropertyOrNull("Discoverable")
            )
        )
    )

    // Extract stack data from the parsed JSON, falling back to resource stack labels if Stacks is not present
    let (stacksFromJson = parsed.Stacks.toList().map((stack) -> Map(
            "label", stack.Label,
            "description", stack.Description,
            "policies", stack.getPropertyOrNull("Policies")?.toList() ?? List()
            )
        )
    )

    // Extract standalone policies from the parsed JSON
    let (policiesFromJson = if (parsed.getPropertyOrNull("Policies") != null)
        parsed.Policies.toList().map((policy) -> Map(
            "Type", policy.Type,
            "Label", policy.Label,
            "TTLSeconds", policy.getPropertyOrNull("TTLSeconds"),
            "OnDependents", policy.getPropertyOrNull("OnDependents")
            )
        )
    else
        List()
    )

    // Create mapping from original labels to camelCase labels for targets
    let (targetLabelMap = targetsFromJson.fold(Map(), (acc: Map<String, String>, targetData) ->
        let (originalLabel = targetData["label"])
        let (camelCaseLabel = toCamelCase(originalLabel))
        acc.put(originalLabel, camelCaseLabel)
    ))

    // Create mapping from original labels to camelCase labels for stacks
    let (stackLabelMap = stacksFromJson.fold(Map(), (acc: Map<String, String>, stackData) ->
        let (originalLabel = stackData["label"])
        let (camelCaseLabel = toCamelCase(originalLabel))
        acc.put(originalLabel, camelCaseLabel)
    ))

    // Create mapping from original labels to camelCase labels for policies
    let (policyLabelMap = policiesFromJson.fold(Map(), (acc: Map<String, String>, policyData) ->
        let (originalLabel = policyData["Label"] as String)
        let (camelCaseLabel = toCamelCase(originalLabel))
        acc.put(originalLabel, camelCaseLabel)
    ))

    let (dependencyImportsSection = if (dependencyImports.length > 0)
        """

        // Dependency imports
        \(importFormatting(dependencyImports, allImports))
        """
    else
        ""
    )

    // Generate policies section (only if there are standalone policies)
    let (policiesSection = if (policiesFromJson.length > 0)
        parsePolicies(policiesFromJson) + "\n"
    else
        ""
    )

    """
    \(headerImports())

    // Resource imports
    \(importFormatting(imports, allImports))\(dependencyImportsSection)

    forma {\(policiesSection)
        \(parseStacks(stacksFromJson, policyLabelMap))

        \(parseTargets(targetsFromJson))

        \(parseResources(resources, targetLabelMap, stackLabelMap))
    }
    """