# Â© 2025 Platform Engineering Labs Inc.
#
# SPDX-License-Identifier: FSL-1.1-ALv2

import sys
import json
import os
from typing import Dict, Any, List, Set
from pathlib import Path
import re

# Fields in ReadOnlyProperties that should be ignored during comparison
# These are typically dynamic values generated by cloud providers
IGNORED_READONLY_FIELDS: Set[str] = {
    "NameServers",     # Route53 HostedZone - AWS assigns these dynamically
    "Id",              # Most AWS resources - cloud-provider generated identifiers
    "Arn",             # AWS ARNs - generated by AWS
    "CreationTime",    # Timestamps - vary between deployments
    "ModificationTime", # Timestamps - vary between deployments
    "DomainName",
    "RouteTableId",
    "GroupName",
}

# Fields in Properties that should be ignored during comparison
# These are dynamic values that change between deployments
IGNORED_PROPERTY_FIELDS: Set[str] = {
    "GroupName",        # EC2 SecurityGroup - AWS generates random names
    "SecurityGroups",   # Security group IDs are deployment-specific
    "SubnetMappings",   # Subnet mappings contain deployment-specific subnet IDs
     "SourceSecurityGroupOwnerId",
    "SourceSecurityGroupName"
}

# Fields that contain AWS resource IDs that should be ignored during comparison
# These fields contain actual AWS resource IDs that change between deployments
DYNAMIC_ID_FIELDS: Set[str] = {
    "SecurityGroups",   # Contains sg-* IDs
    "Subnets",         # Contains subnet-* IDs
    "SubnetMappings",  # Contains objects with SubnetId fields
}

# Fields that should be compared as sets (order doesn't matter) but after removing dynamic IDs
SET_COMPARISON_FIELDS: Set[str] = {
    # All array fields should be compared without regard to order
}

def load_json(path):
    with open(path) as f:
        return json.load(f)

def is_dynamic_id_field(field_name: str) -> bool:
    """Check if a field name suggests it contains dynamic IDs"""
    field_lower = field_name.lower()
    return 'id' in field_lower and field_name not in ['Type', 'VpcId']  # Exclude common non-ID fields

def normalize_tags(tags):
    """Sort tags by Key for consistent comparison"""
    if isinstance(tags, list) and all(isinstance(tag, dict) and 'Key' in tag for tag in tags):
        return sorted(tags, key=lambda x: x['Key'])
    return tags

def normalize_array_field(field_name: str, value: Any) -> Any:
    """Normalize array fields - ALL arrays should be compared without regard to order"""
    if not isinstance(value, list):
        return value

    # Handle special cases with specific sorting logic
    if field_name == "Tags":
        return normalize_tags(value)
    else:
        # For all other array fields, sort them for consistent comparison
        try:
            return sorted(value)
        except TypeError:
            # If items aren't sortable (e.g., dicts), convert to sorted JSON strings
            return sorted([json.dumps(item, sort_keys=True) if isinstance(item, dict) else str(item) for item in value])

def remove_dynamic_ids_from_array(field_name: str, value: Any) -> Any:
    """Remove or mask dynamic AWS resource IDs from arrays"""
    if not isinstance(value, list):
        return value

    if field_name in DYNAMIC_ID_FIELDS:
        if field_name == "SubnetMappings":
            # For SubnetMappings, replace SubnetId values with placeholder
            result = []
            for item in value:
                if isinstance(item, dict) and "SubnetId" in item:
                    new_item = item.copy()
                    new_item["SubnetId"] = "<DYNAMIC_SUBNET_ID>"
                    result.append(new_item)
                else:
                    result.append(item)
            return sorted(result, key=lambda x: json.dumps(x, sort_keys=True))
        else:
            # For SecurityGroups and Subnets, replace with placeholders and sort
            result = []
            for item in value:
                if field_name == "SecurityGroups":
                    result.append("<DYNAMIC_SECURITY_GROUP_ID>")
                elif field_name == "Subnets":
                    result.append("<DYNAMIC_SUBNET_ID>")
                else:
                    result.append("<DYNAMIC_ID>")
            return sorted(result)

    return value

def normalize_empty_values(obj: Any) -> Any:
    """Recursively remove empty arrays and empty objects from a dict for comparison.
    This handles cases where the actual output omits empty values while expected includes them."""
    if isinstance(obj, dict):
        result = {}
        for key, value in obj.items():
            normalized = normalize_empty_values(value)
            # Skip empty arrays and empty dicts
            if normalized == [] or normalized == {}:
                continue
            result[key] = normalized
        return result
    elif isinstance(obj, list):
        return [normalize_empty_values(item) for item in obj]
    else:
        return obj

def remove_dynamic_values(obj: Any, field_path: str = "") -> Any:
    """Recursively remove dynamic values that shouldn't be compared"""
    if isinstance(obj, dict):
        result = {}
        for key, value in obj.items():
            current_path = f"{field_path}.{key}" if field_path else key

            if isinstance(value, dict) and "$res" in value:
                # Keep $res structure but remove $value
                result[key] = {
                    "$res": value["$res"],
                    "$label": value["$label"],
                    "$type": value["$type"],
                    "$property": value["$property"],
                }
                # Preserve $visibility and $stack if they exist
                for preserve_key in ["$visibility", "$stack"]:
                    if preserve_key in value:
                        result[key][preserve_key] = value[preserve_key]
                # Explicitly do NOT copy $value since it's dynamic
            elif key in IGNORED_PROPERTY_FIELDS:
                # Skip dynamic property fields completely
                continue
            elif is_dynamic_id_field(key) and isinstance(value, str):
                # Replace dynamic ID values with placeholder
                result[key] = f"<DYNAMIC_{key.upper()}>"
            else:
                # First normalize arrays that should be compared as sets
                normalized_value = normalize_array_field(key, value)
                # Then remove dynamic IDs from arrays
                filtered_value = remove_dynamic_ids_from_array(key, normalized_value)
                result[key] = remove_dynamic_values(filtered_value, current_path)
        return result
    elif isinstance(obj, list):
        return [remove_dynamic_values(item, field_path) for item in obj]
    else:
        return obj

def filter_readonly_properties(readonly_props: Dict[str, Any]) -> Dict[str, Any]:
    """Remove ignored fields from ReadOnlyProperties but keep field names only"""
    result = {}
    for k, v in readonly_props.items():
        if k in IGNORED_READONLY_FIELDS:
            continue
        else:
            # Keep the field name but replace value with placeholder since we only care about field existence
            result[k] = "<READONLY_VALUE>"
    return result

def compare_single_resource(actual_resource: Dict, expected_resource: Dict, resource_label: str) -> bool:
    """Compare a single resource with special handling for identifiers and references"""

    # Compare all properties EXCEPT special cases that have custom handling below
    # - NativeID, ReadOnlyProperties, Ksuid: have special handling
    # - Schema: resource type metadata that may evolve
    # - Properties: has special handling for empty values and identifiers
    for key in expected_resource:
        if key in ["NativeID", "ReadOnlyProperties", "Ksuid", "Schema", "Properties"]:
            continue
        if normalize_empty_values(remove_dynamic_values(actual_resource.get(key))) != normalize_empty_values(remove_dynamic_values(expected_resource.get(key))):
            print(f"Resource '{resource_label}' property '{key}' differs")
            print(f"\tActual: {actual_resource.get(key)}")
            print(f"\tExpected: {expected_resource.get(key)}")
            return False

    # Get the identifier field from schema
    schema = actual_resource.get("Schema", {})
    identifier_field = schema.get("Identifier")

    # Compare Properties (with special handling for dynamic values and identifiers)
    actual_props = actual_resource.get("Properties", {})
    expected_props = expected_resource.get("Properties", {})

    # Remove identifier from properties before comparison if it exists there
    # Also normalize empty values (missing field == empty array/dict)
    actual_props_filtered = normalize_empty_values(remove_dynamic_values(actual_props.copy()))
    expected_props_filtered = normalize_empty_values(remove_dynamic_values(expected_props.copy()))

    if identifier_field and identifier_field in actual_props_filtered:
        # Check identifier exists but don't compare its value
        if identifier_field not in expected_props_filtered:
            print(f"Resource '{resource_label}' missing identifier '{identifier_field}' in Properties")
            return False
        # Remove identifier values for comparison
        actual_props_filtered.pop(identifier_field, None)
        expected_props_filtered.pop(identifier_field, None)

    if actual_props_filtered != expected_props_filtered:
        print(f"Resource '{resource_label}' Properties differ")
        print(f"\tActual: {json.dumps(actual_props_filtered, indent=2, sort_keys=True)}")
        print(f"\tExpected: {json.dumps(expected_props_filtered, indent=2, sort_keys=True)}")
        return False

    # For ReadOnlyProperties, remove dynamic values first, then filter out ignored fields
    actual_readonly = actual_resource.get("ReadOnlyProperties", {})
    expected_readonly = expected_resource.get("ReadOnlyProperties", {})

    # First remove dynamic values
    actual_readonly_filtered = remove_dynamic_values(actual_readonly)
    expected_readonly_filtered = remove_dynamic_values(expected_readonly)

    # Then filter out ignored fields and replace dynamic IDs
    actual_readonly_filtered = filter_readonly_properties(actual_readonly_filtered)
    expected_readonly_filtered = filter_readonly_properties(expected_readonly_filtered)

    # Compare the filtered ReadOnlyProperties
    if actual_readonly_filtered != expected_readonly_filtered:
        print(f"Resource '{resource_label}' ReadOnlyProperties differ (after filtering ignored fields)")
        print(f"Ignored fields: {list(IGNORED_READONLY_FIELDS)}")
        print(f"\tActual (filtered): {json.dumps(actual_readonly_filtered, indent=2, sort_keys=True)}")
        print(f"\tExpected (filtered): {json.dumps(expected_readonly_filtered, indent=2, sort_keys=True)}")
        # Disable compare for readonly properties since they might change
        # return False

    return True

def find_resource_in_list(resources: List[Dict], stack: str, label: str) -> Dict:
    """Find a resource in the list by Stack and Label"""
    for resource in resources:
        if resource.get("Stack") == stack and resource.get("Label") == label:
            return resource
    return None

def compare_resources_with_file(actual_file: str, expected_dir: str) -> bool:
    """Compare resources where actual is a JSON file with array of resources and expected is a directory of files"""
    actual_path = Path(actual_file)
    expected_path = Path(expected_dir)

    if not actual_path.exists():
        print(f"Actual file does not exist: {actual_file}")
        return False

    if not expected_path.exists():
        print(f"Expected directory does not exist: {expected_dir}")
        return False

    # Load the actual resources from the JSON file
    try:
        actual_resources = load_json(actual_file)
        if not isinstance(actual_resources, list):
            print(f"Actual file must contain an array of resources: {actual_file}")
            return False
    except Exception as e:
        print(f"Error loading actual file {actual_file}: {e}")
        return False

    # Get all JSON files in expected directory
    expected_files = list(expected_path.glob("*.json"))

    if not expected_files:
        print(f"No expected JSON files found in: {expected_dir}")
        return False

    success = True

    for expected_file in expected_files:
        try:
            expected_resource = load_json(expected_file)
            expected_stack = expected_resource.get("Stack")
            expected_label = expected_resource.get("Label")

            if not expected_stack or not expected_label:
                print(f"Expected resource missing Stack or Label in {expected_file.name}")
                success = False
                continue

            # Find matching resource in actual resources
            actual_resource = find_resource_in_list(actual_resources, expected_stack, expected_label)

            if not actual_resource:
                print(f"No matching resource found for Stack='{expected_stack}', Label='{expected_label}' in actual file")
                success = False
                continue

            resource_identifier = f"{expected_stack}/{expected_label}"

            if not compare_single_resource(actual_resource, expected_resource, resource_identifier):
                print(f"Resource comparison failed for: {expected_file.name} (Stack='{expected_stack}', Label='{expected_label}')")
                success = False
            else:
                print(f"Resource comparison passed for: {expected_file.name} (Stack='{expected_stack}', Label='{expected_label}')")

        except Exception as e:
            print(f"Error comparing {expected_file.name}: {e}")
            success = False

    return success

def main():
    if len(sys.argv) != 3:
        print("Usage: compare_resources.py actual_file expected_dir")
        print("  actual_file: JSON file containing array of actual resources")
        print("  expected_dir: Directory containing expected resource JSON files")
        sys.exit(1)

    actual_file = sys.argv[1]
    expected_dir = sys.argv[2]

    try:
        if compare_resources_with_file(actual_file, expected_dir):
            print(f"All resources match (ignoring dynamic values, ReadOnly fields: {list(IGNORED_READONLY_FIELDS)}, Property fields: {list(IGNORED_PROPERTY_FIELDS)}, Dynamic ID fields: {list(DYNAMIC_ID_FIELDS)}, and any field containing 'id'/'Id').")
            sys.exit(0)
        else:
            print("Resource comparison failed")
            sys.exit(2)

    except Exception as e:
        print(f"Error comparing file to directory: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()