# Â© 2025 Platform Engineering Labs Inc.
#
# SPDX-License-Identifier: FSL-1.1-ALv2

import sys
import json
import os
from typing import Dict, Any, List, Set
from pathlib import Path

# Fields in ReadOnlyProperties that should be ignored during comparison
# These are typically dynamic values generated by cloud providers
IGNORED_READONLY_FIELDS: Set[str] = {
    "NameServers",     # Route53 HostedZone - AWS assigns these dynamically
    "Id",              # Most AWS resources - cloud-provider generated identifiers
    "Arn",             # AWS ARNs - generated by AWS
    "CreationTime",    # Timestamps - vary between deployments
    "ModificationTime", # Timestamps - vary between deployments
    "DomainName",
}

def load_json(path):
    with open(path) as f:
        return json.load(f)

def remove_dynamic_values(obj: Any) -> Any:
    """Recursively remove dynamic values that shouldn't be compared"""
    if isinstance(obj, dict):
        result = {}
        for key, value in obj.items():
            if isinstance(value, dict) and "$res" in value:
                # Keep $res structure but remove $value
                result[key] = {
                    "$res": value["$res"],
                    "$label": value["$label"],
                    "$type": value["$type"],
                    "$property": value["$property"],
                }
                # Preserve $visibility if it exists
                if "$visibility" in value:
                    result[key]["$visibility"] = value["$visibility"]
                # Explicitly do NOT copy $value
            else:
                result[key] = remove_dynamic_values(value)
        return result
    elif isinstance(obj, list):
        return [remove_dynamic_values(item) for item in obj]
    else:
        return obj

def filter_readonly_properties(readonly_props: Dict[str, Any]) -> Dict[str, Any]:
    """Remove ignored fields from ReadOnlyProperties"""
    return {k: v for k, v in readonly_props.items() if k not in IGNORED_READONLY_FIELDS}

def compare_single_resource(actual_resource: Dict, expected_resource: Dict, resource_label: str) -> bool:
    """Compare a single resource with special handling for identifiers and references"""

    # Compare all properties EXCEPT NativeId and ReadOnlyProperties (which have special handling)
    for key in expected_resource:
        if key in ["NativeID", "ReadOnlyProperties", "Ksuid"]:
            continue
        if remove_dynamic_values(actual_resource.get(key)) != remove_dynamic_values(expected_resource.get(key)):
            print(f"Resource '{resource_label}' property '{key}' differs")
            print(f"\tActual: {actual_resource.get(key)}")
            print(f"\tExpected: {expected_resource.get(key)}")
            return False

    # Get the identifier field from schema
    schema = actual_resource.get("Schema", {})
    identifier_field = schema.get("Identifier")

    # Compare Properties (with special handling for dynamic values and identifiers)
    actual_props = actual_resource.get("Properties", {})
    expected_props = expected_resource.get("Properties", {})

    # Remove identifier from properties before comparison if it exists there
    actual_props_filtered = remove_dynamic_values(actual_props.copy())
    expected_props_filtered = remove_dynamic_values(expected_props.copy())

    if identifier_field and identifier_field in actual_props_filtered:
        # Check identifier exists but don't compare its value
        if identifier_field not in expected_props_filtered:
            print(f"Resource '{resource_label}' missing identifier '{identifier_field}' in Properties")
            return False
        # Remove identifier values for comparison
        actual_props_filtered.pop(identifier_field, None)
        expected_props_filtered.pop(identifier_field, None)

    if actual_props_filtered != expected_props_filtered:
        print(f"Resource '{resource_label}' Properties differ")
        print(f"\tActual: {json.dumps(actual_props_filtered, indent=2)}")
        print(f"\tExpected: {json.dumps(expected_props_filtered, indent=2)}")
        return False

    # For ReadOnlyProperties, remove dynamic values first, then filter out ignored fields
    actual_readonly = actual_resource.get("ReadOnlyProperties", {})
    expected_readonly = expected_resource.get("ReadOnlyProperties", {})

    # First remove dynamic values
    actual_readonly_filtered = remove_dynamic_values(actual_readonly)
    expected_readonly_filtered = remove_dynamic_values(expected_readonly)

    # Then filter out ignored fields
    actual_readonly_filtered = filter_readonly_properties(actual_readonly_filtered)
    expected_readonly_filtered = filter_readonly_properties(expected_readonly_filtered)

    # Compare the filtered ReadOnlyProperties
    if actual_readonly_filtered != expected_readonly_filtered:
        print(f"Resource '{resource_label}' ReadOnlyProperties differ (after filtering ignored fields)")
        print(f"Ignored fields: {list(IGNORED_READONLY_FIELDS)}")
        print(f"\tActual (filtered): {json.dumps(actual_readonly_filtered, indent=2)}")
        print(f"\tExpected (filtered): {json.dumps(expected_readonly_filtered, indent=2)}")
        # Disable compare for readonly properties since they might change
        # return False

    return True

def find_resource_in_list(resources: List[Dict], stack: str, label: str) -> Dict:
    """Find a resource in the list by Stack and Label"""
    for resource in resources:
        if resource.get("Stack") == stack and resource.get("Label") == label:
            return resource
    return None

def compare_resources_with_file(actual_file: str, expected_dir: str) -> bool:
    """Compare resources where actual is a JSON file with array of resources and expected is a directory of files"""
    actual_path = Path(actual_file)
    expected_path = Path(expected_dir)

    if not actual_path.exists():
        print(f"Actual file does not exist: {actual_file}")
        return False

    if not expected_path.exists():
        print(f"Expected directory does not exist: {expected_dir}")
        return False

    # Load the actual resources from the JSON file
    try:
        actual_resources = load_json(actual_file)
        if not isinstance(actual_resources, list):
            print(f"Actual file must contain an array of resources: {actual_file}")
            return False
    except Exception as e:
        print(f"Error loading actual file {actual_file}: {e}")
        return False

    # Get all JSON files in expected directory
    expected_files = list(expected_path.glob("*.json"))

    if not expected_files:
        print(f"No expected JSON files found in: {expected_dir}")
        return False

    success = True

    for expected_file in expected_files:
        try:
            expected_resource = load_json(expected_file)
            expected_stack = expected_resource.get("Stack")
            expected_label = expected_resource.get("Label")

            if not expected_stack or not expected_label:
                print(f"Expected resource missing Stack or Label in {expected_file.name}")
                success = False
                continue

            # Find matching resource in actual resources
            actual_resource = find_resource_in_list(actual_resources, expected_stack, expected_label)

            if not actual_resource:
                print(f"No matching resource found for Stack='{expected_stack}', Label='{expected_label}' in actual file")
                success = False
                continue

            resource_identifier = f"{expected_stack}/{expected_label}"

            if not compare_single_resource(actual_resource, expected_resource, resource_identifier):
                print(f"Resource comparison failed for: {expected_file.name} (Stack='{expected_stack}', Label='{expected_label}')")
                success = False
            else:
                print(f"Resource comparison passed for: {expected_file.name} (Stack='{expected_stack}', Label='{expected_label}')")

        except Exception as e:
            print(f"Error comparing {expected_file.name}: {e}")
            success = False

    return success

def main():
    if len(sys.argv) != 3:
        print("Usage: compare_resources.py actual_file expected_dir")
        print("  actual_file: JSON file containing array of actual resources")
        print("  expected_dir: Directory containing expected resource JSON files")
        sys.exit(1)

    actual_file = sys.argv[1]
    expected_dir = sys.argv[2]

    try:
        if compare_resources_with_file(actual_file, expected_dir):
            print(f"All resources match (ignoring dynamic values and ReadOnly fields: {list(IGNORED_READONLY_FIELDS)}).")
            sys.exit(0)
        else:
            print("Resource comparison failed")
            sys.exit(2)

    except Exception as e:
        print(f"Error comparing file to directory: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()